import java.util.*;
import java.util.stream.Collectors;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class Library {

    public boolean someLibraryMethod() {
        return true;
    }

    private static HashMap<String, TreeSet<Pack>> packHashMap = new HashMap<>();
    private static HashMap<Integer, Pack> result = new HashMap<>();
    private static double totalCost = 0;
    private static int processedOrderSize = 0;

    public static void main(String[] args) {
        loadData();
        Scanner s = new Scanner(System.in);
        while (s.hasNext()) {
            int orderSize = s.nextInt();
            String nextString = s.next();
            result.clear();
            totalCost = 0;
            processedOrderSize = 0;
            calculate(orderSize, packHashMap.get(nextString), nextString);
        }
    }

    private static void calculate(int orderSize, TreeSet<Pack> packList, String code) {

        TreeSet<Pack> duplicatePackList = new TreeSet<>(packList);
        packList.forEach(pack -> {
            duplicatePackList.remove(pack);
            if (orderSize > processedOrderSize)
            checkMod(orderSize, pack, duplicatePackList);
        });

        System.out.println(orderSize+ " " + code + " $" + totalCost);
        result.forEach((numberOfPacks, pack) -> {
            System.out.println(numberOfPacks + " x " + pack);
        });


    }

    private static void checkMod(int orderSize, Pack pack, TreeSet<Pack> packs) {
        int mod = Math.floorMod(orderSize, pack.getSize());
        List<Integer> packSizeList = packs.stream().map(Pack::getSize).collect(Collectors.toList());

        int packCount = orderSize / pack.getSize();
        if (mod == 0)
        {
            result.put(packCount, pack);
            totalCost += pack.getCost() * packCount;
            processedOrderSize += packCount * pack.getSize();
            return;
        }
        else if (packSizeList.contains(mod)) {
            result.put(packCount, pack);
            totalCost += pack.getCost() * packCount;
            processedOrderSize += packCount * pack.getSize();
            Optional<Pack> first = packs.stream().filter(pack1 -> pack1.getSize() == mod).findFirst();
            first.ifPresent(pack1 -> {
                result.put(1, pack1);
                totalCost += pack1.getCost();
                processedOrderSize += pack1.getSize();
            });

            return;
        }
        else {
            Optional<Pack> first = packs.stream().filter(pack1 -> Math.floorMod(mod, pack1.getSize()) == 0).findFirst();
            first.ifPresent( pack1 -> {
                 result.put(packCount, pack);
                 result.put(mod/pack1.getSize(), pack1);
                 totalCost += pack.getCost() * packCount + pack1.getCost() * mod/pack1.getSize();
                 processedOrderSize += packCount * pack.getSize() + (pack1.getSize() * (mod/pack1.getSize()));
                 return;

             });
        }
    }


    private static void loadData()
    {
        TreeSet<Pack> vs5SizeValueList = new TreeSet<>();
        vs5SizeValueList.add(new Pack(3, 6.99));
        vs5SizeValueList.add(new Pack(5, 8.99));
        packHashMap.put("VS5", vs5SizeValueList);

        TreeSet<Pack> mb11PackList = new TreeSet<>();

        mb11PackList.add(new Pack(2, 9.95));
        mb11PackList.add(new Pack(5, 16.95));
        mb11PackList.add(new Pack(8, 24.95));
        packHashMap.put("MB11", mb11PackList);

        TreeSet<Pack> cfPackList = new TreeSet<>();
        cfPackList.add(new Pack(3, 5.95));
        cfPackList.add(new Pack(5, 9.95));
        cfPackList.add(new Pack(9, 16.99));
        packHashMap.put("CF", cfPackList);
    }
}
